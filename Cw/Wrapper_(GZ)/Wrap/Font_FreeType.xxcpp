//This file is part of "GZE - GroundZero Engine"

//The permisive licence allow to use GZE for free or commercial project (Apache License, Version 2.0).
//For conditions of distribution and use, see copyright notice in Licence.txt, this license must be included with any distribution of the code.

//Though not required by the license agreement, please consider the following will be greatly appreciated:
//- We would like to hear about projects where GZE is used.
//- Include an attribution statement somewhere in your project.
//- If you want to see GZE evolve please help us with a donation.

#include "Font.h"
#include "Lib_GZ/File/RcImg.h"
#include "Lib_GZ/File/RcFont.h"

#include "Lib_GZ/Lib/Utils/stb_rect_pack.h"
#include "Math.h"
#include "Lib_GZ/Sys/Debug.h"

#ifndef GZ_tNo_FreeType
#include <ft2build.h>
#include FT_FREETYPE_H


namespace Lib_GZ{namespace Wrap{
cRcFont* oRcFont;

namespace Font{

gzQArray< gzPod<uFontRange> > qaRange;




void load_fonts(void);
void fLoadFont(FT_Face _oFace);
int fPackFontRanges(uPackContext *spc, uFontRange *ranges, int _nNbRange);


int fPackFontRange(uPackContext *spc, gzFloat _FontSize, gzUInt _nFirstChar, gzUInt _nNbChar, uCharData *chardata_for_range);

 int fPackBegin(uPackContext *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context);
void fPackEnd  (uPackContext *spc);

FT_Face oFace;

//char buffer[24<<20];
//unsigned char screen[20][79];

uCharData* rInvalidChar;

gzInt fOpen(cRcFont* _oRc) {
oRcFont = _oRc;

    Debug::fError(gzU8("------Open Font--"));
	
	
    FT_Library ft;
    if (FT_Init_FreeType(&ft)){
        Debug::fError(gzU8("ERROR::FREETYPE: Could not init FreeType Library"));
    }

    FT_Face face;
 //   if (FT_New_Face(ft, "c:/windows/fonts/consola.ttf", 0, &face)){
    if (FT_New_Face(ft, "c:/windows/fonts/arial.ttf", 0, &face)){
        Debug::fError(gzU8("ERROR::FREETYPE: Failed to load font"));
    }

    //FT_Set_Pixel_Sizes(face, 0, 9.5);
    FT_Set_Pixel_Sizes(face, 0, 24.5);

    if (FT_Load_Char(face, ' ', FT_LOAD_RENDER)){
        Debug::fError(gzU8("ERROR::FREETYPE: Failed to load char"));
    }
    rInvalidChar  = (uCharData*)GZ_fMalloc(1, sizeof(uCharData));
    FT_Glyph_Metrics_* metrics = &face->glyph->metrics;
    rInvalidChar->nHoriAdvance =    metrics->horiAdvance;
    rInvalidChar->nHoriBeringX =    metrics->horiBearingX;
    rInvalidChar->nHoriBeringY =    metrics->horiBearingY;
    rInvalidChar->rRect = (uRectPack*)GZ_fCalloc(1 , sizeof(uRectPack) );




   Debug::fError(gzU8("OK"));
    oFace = face;
    fLoadFont(face);

	return 0;
}


uCharData aChardata[6][128];
//unsigned char aTTF_buffer[1 << 25];

#define tSIZE 512
#include "Windows.h"
unsigned char aBmpPack[tSIZE][tSIZE] = { {0}};


void fLoadFont(FT_Face _oFace){

    uPackContext pc;
    fPackBegin(&pc, aBmpPack[0], tSIZE, tSIZE, 0, 2, NULL);
    fPackFontRange(&pc, 12.0, 32, 95, aChardata[1]+32);
    fPackEnd(&pc);

    gzInt BITMAP_W =  tSIZE;
    gzInt BITMAP_H =  tSIZE;

    char nBoder = 0;
    char nBoder_x2 = nBoder * 2;
    gzUInt nExtWidth = BITMAP_W + 0;
    gzUInt nExtHeight = BITMAP_H + 0;

    gzInt** p2DArray;
    p2DArray = new gzInt*[nExtHeight];

    gzInt* p1DArray = (gzInt *)GZ_fCalloc(nExtHeight * nExtWidth , sizeof(gzInt) );

    for (gzInt y = 0;  y < BITMAP_H;  y++){
           char* RowY = (char*)&aBmpPack[y][0];
             for (gzInt x = 0;  x < BITMAP_W;  x++){

                   gzUInt _nPixelFrame =  0;
                    gzUInt _nFrameAlpha = RowY[x];

                   gzUInt _nFrameBlue = _nPixelFrame;
                   gzUInt _nFrameGreen = _nPixelFrame;
                   gzUInt _nFrameRed = _nPixelFrame;

                    p1DArray[((y) *  nExtWidth) + (x) ]  = (_nFrameAlpha << 24) | (_nFrameRed << 16) | (_nFrameGreen << 8) | _nFrameBlue;
                    p2DArray[(y)] = &p1DArray[((y) *  nExtWidth)];
        }
    }

    oRcFont->aImg = p2DArray;
    oRcFont->nWidth = BITMAP_W-2;
    oRcFont->nHeight = BITMAP_H-2;
}



 void fPackEnd  (uPackContext *spc){

   GZ_fFree(spc->nodes    );
   GZ_fFree(spc->pack_info);
}


 int fPackBegin(uPackContext *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)
{
   stbrp_context *context = (stbrp_context *) GZ_fMalloc(sizeof(*context)   ,1  );
   int            num_nodes = pw - padding;
   stbrp_node    *nodes   = (stbrp_node    *) GZ_fMalloc(sizeof(*nodes  ) , num_nodes);

   if (context == NULL || nodes == NULL) {
      if (context != NULL) GZ_fFree(context);
      if (nodes   != NULL) GZ_fFree(nodes );
      return 0;
   }

   spc->user_allocator_context = alloc_context;
   spc->width = pw;
   spc->height = ph;
   spc->pixels = pixels;
   spc->pack_info = context;
   spc->nodes = nodes;
   spc->padding = padding;
   spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;


   stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);

  // memset(pixels, 0, pw*ph); // background of 0 around pixels

   return 1;
}


void fDeleteRange(GZ_FuncWrapD, void* _wRange){
    uFontRange* _rRange = (uFontRange*)_wRange;

    uCharData** aData  =_rRange->aData;
    for(gzUInt i = 0; i < _rRange->nNbChar ; i++){
       GZ_fFree(aData[i]);
    }
     GZ_fFree(_rRange->aData);
}



int fPackFontRange(uPackContext *spc, gzFloat _FontSize, gzUInt _nFirstChar, gzUInt _nNbChar, uCharData *chardata_for_range){

   uCharData** aData  = (uCharData**)GZ_fMalloc(_nNbChar, sizeof(uCharData*));
    for(gzUInt i = 0; i < _nNbChar; i++){
        aData[i] = (uCharData*)GZ_fMalloc(1, sizeof(uCharData));
    }

   uFontRange* rRange  = (uFontRange*)GZ_fMalloc(1, sizeof(uFontRange));

   rRange->nFirstChar = _nFirstChar;
   rRange->nNbChar          = _nNbChar;
   rRange->aData       = aData;
   rRange->nFontSize    = _FontSize;

    //qaRange.fPush(gzPodLinkOwn(range));
    qaRange.fPush(gzPodLinkOwn(rRange, &fDeleteRange));

   return fPackFontRanges(spc, rRange, 1);
}


int fPackFontRanges(uPackContext *spc, uFontRange *_aRanges, int _nNbRange){

   stbrp_context *context = (stbrp_context *) spc->pack_info;
   stbrp_rect    *rects;

  int i,j,k,n, return_value = 1;
   // flag all characters as NOT packed
   for (i=0; i < _nNbRange; ++i)
      for (j=0; j < _aRanges[i].nNbChar; ++j)
         _aRanges[i].aData[j]->nX =
         _aRanges[i].aData[j]->nY =
         _aRanges[i].aData[j]->nW =
         _aRanges[i].aData[j]->nH = 0;

   n = 0;
   for (i=0; i < _nNbRange; ++i)
      n += _aRanges[i].nNbChar;

   rects = (stbrp_rect *) GZ_fMalloc(sizeof(*rects) , n);
   if (rects == NULL){
      return 0;
   }

    if (FT_Load_Char(oFace, 'e', FT_LOAD_RENDER)){
        Debug::fError(gzU8("ERROR::FREETYPE: Failed to load char"));
    }

   k=0;
   for (i=0; i < _nNbRange; ++i) {
      float fh = _aRanges[i].nFontSize;

      for (j=0; j < _aRanges[i].nNbChar; ++j) {

       if (FT_Load_Char(oFace,  _aRanges[i].nFirstChar + j,FT_LOAD_DEFAULT)){
      //  if (FT_Load_Char(oFace,  ranges[i].first_unicode_char_in_range + j,FT_LOAD_RENDER)){
            Debug::fError(gzU8("ERROR::FREETYPE: Failed to load char"));
        }

        FT_Glyph_Metrics_* metrics = &oFace->glyph->metrics;
        rects[k].w = metrics->width/64.0 + 2.0;
        rects[k].h = metrics->height/64.0 + 2.0;
        //rects[k].w =  oFace->glyph->bitmap.width + 2;
        //rects[k].h =  oFace->glyph->bitmap.rows  + 2;
         ++k;
      }
   }

   stbrp_pack_rects(context, rects, k);

    //Draw in shorted square
   k = 0;
   for (i=0; i < _nNbRange; ++i) {
      float fh = _aRanges[i].nFontSize;
      for (j=0; j < _aRanges[i].nNbChar; ++j) {
         stbrp_rect *r = &rects[k];
         if (r->was_packed) {
            uCharData* _rChar = _aRanges[i].aData[j];

            if (FT_Load_Char(oFace,  _aRanges[i].nFirstChar + j,FT_LOAD_RENDER )){
                Debug::fError(gzU8("ERROR::FREETYPE: Failed to load char"));
            }

            unsigned char* aGlyph = oFace->glyph->bitmap.buffer;

            for (gzUInt y = 0; y < r->h - 2; y ++){
                 for (gzUInt x = 0; x < r->w-2; x ++){
                    gzUInt _nX = r->x + x+1;
                    gzUInt _nY = r->y + y+1;

                     spc->pixels[spc->width * _nY +  _nX] = aGlyph[ ( oFace->glyph->bitmap.pitch * y) + x];
                }
            }

            FT_Glyph_Metrics_* metrics = &oFace->glyph->metrics;

            gzFloat scale = 24;

            _rChar->nHoriAdvance =    metrics->horiAdvance;
            _rChar->nHoriBeringX =    metrics->horiBearingX;
            _rChar->nHoriBeringY =    metrics->horiBearingY;

            _rChar->rRect = (uRectPack*)r;

         } else {
            return_value = 0; // if any fail, report failure
         }

         ++k;
      }
   }

 //  GZ_fFree(rects); ****** HUDGE BUG ****
   return return_value;
}


uCharData* fGetCharData(gzUInt _nChar){

    gzUInt nTotalRange = 1;
    gzUInt k = 0;
    gzFOR_EACH_QArrayNew(qaRange, _qe_rRange, gzPod<uFontRange>){
		uFontRange* _pRange = _qe_rRange.val()->Val;
        if(_nChar >= _pRange->nFirstChar  && _nChar < _pRange->nFirstChar + _pRange->nNbChar){
            gzUInt _nIndex = _nChar - _pRange->nFirstChar;
            //uCharData* _sRest = _pRange->aData[_nIndex];
            return (uCharData*)_pRange->aData[_nIndex];
        }
   	gzEND_QArray(_qe_rRange)}
   return rInvalidChar;
}





gzInt fDelete(cRcFont* _oRc){





/*
    //free all
    gzInt32** _aPixelArray = _oRc->aImg;
    if(_aPixelArray != 0){

      GZ_fFree(_aPixelArray[0]);
        //Todo delete P2D array
    }*/

    return 0;
}
}

}//GZ


#else

namespace Lib_GZ{namespace Wrap{
    namespace pFont{
        gzInt fOpen(File::cRcFont* _oRc){return 0;};
        gzInt fDelete(File::cRcFont* _oRc){return 0;};
        Font::uCharData* fGetCharData(gzUInt _nChar){return 0;};
    }
}}

#endif





